<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构-线性表以及实现方式</title>
      <link href="/2020/03/19/xian-xing-biao/"/>
      <url>/2020/03/19/xian-xing-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>线性表是最基本和最简单的一类数据结构，它表示的是线性结构。在线性结构中，数据元素之间存在着<strong>一对一</strong>的关系，其特点是数据元素之间按照某种规定存在一个顺序关系。</p><h3 id="1-1线性表的定义"><a href="#1-1线性表的定义" class="headerlink" title="1.1线性表的定义"></a>1.1线性表的定义</h3><p>线性表：n个同类型数据元素的有限序列，记为：</p><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/20200319230240.png" alt=""></p><p>L为表名；<br>i为数据元素a_i在线性表中的位序；<br>n为线性表的表除；n=0时成为空表。<br>数据元素之间的关系时：</p><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/20200319230553.png" alt=""></p><p>除去第一元素a1外，都有唯一的前驱，除去最后元素an外，都有唯一的后继。</p><hr><h1 id="二-线性表的实现方式和基本操作"><a href="#二-线性表的实现方式和基本操作" class="headerlink" title="二 线性表的实现方式和基本操作"></a>二 线性表的实现方式和基本操作</h1><p>线性表是一种逻辑结构，在计算机上面表示可以使用顺序存储结构和链式存储结构来实现。</p><p>顺序存储结构是把逻辑上相邻的元素存储在物理位置相邻的存储单元上面，而链式存储结构是在数据元素种添加一些地址域或者辅助结构，用来存放数据元素之间的关系。<br>顺序存储结构在计算机中可以使用数组来实现，链式存储结构可以用链表来实现。</p><p>线性表的操作可以分为变动性操作和非变动性操作，而基于这2大类可以分为以下操作：</p><p>变动性操作：</p><ul><li>创建线性表（创建空表，创建带有元素的表）</li><li>插入元素（根据位置插入，在尾部插入）</li><li>修改元素值</li><li>删除元素值（根据位置删除，根据元素值删除）</li></ul><p>非变动性操作：</p><ul><li>获取线性表长度（顺序存储方式需要获取表最大容量）</li><li>遍历线性表</li><li>查找元素（根据位置查，根据元素值查）</li></ul><p>这只是基本操作，有其他对元素的操作根据自己需求撰写算法。</p><hr><h1 id="三、-线性表顺序存储实现"><a href="#三、-线性表顺序存储实现" class="headerlink" title="三、 线性表顺序存储实现"></a>三、 线性表顺序存储实现</h1><p>在写一些插入函数的时候，需要返回一个状态来表示成功与否，这里写一个枚举类型来表示状态</p><pre class=" language-c++"><code class="language-c++">enum Status { SUCCESS, FAIL, RANGE_ERROR, OVER_FLOW, EMPTY };</code></pre><p>顺序存储实现需要数组实现，数据成员要有一个数组且要2个成员表示该线性表的长度和该表的最大容量。</p><h2 id="3-1-类体结构："><a href="#3-1-类体结构：" class="headerlink" title="3.1 类体结构："></a>3.1 类体结构：</h2><pre><code>template&lt;class DataType&gt;class SeqList(){private:    DataType *data;    //数组    int length;        //该线性表的长度    int maxLength;    //该线性表的最大长度 public:    SeqList(int size);    ~SeqList();    int GetLength()const;    int GetMaxLength()const;    void display()const;    Status Insert(DataType&amp; elem);    Status Insert(int i , DataType&amp; elem);    Status Delete(int i);    Status Delete(DataType &amp;elem);    Status DeleteEqualValue(DataType &amp;elem);    Status GetData(int i , DataType &amp;elem)const;};</code></pre><p>类内所有函数的实现：</p><h2 id="3-2-构造函数"><a href="#3-2-构造函数" class="headerlink" title="3.2 构造函数"></a>3.2 构造函数</h2><pre><code>template&lt;class DataType&gt;SeqList&lt;DataType&gt;::SeqList(int size){    DataType *data = new DataType[size];    length = 0;    maxLength = size;    //构造函数，对数据成员赋值，data处根据new字符动态创建一个size大小的数组}</code></pre><h2 id="3-3-析构函数"><a href="#3-3-析构函数" class="headerlink" title="3.3 析构函数"></a>3.3 析构函数</h2><pre><code>template&lt;class DataType&gt;SeqList&lt;DataType&gt;::~SeqList(){    delete []data;    //析构函数，对使用new运算符构造出来的要手动delete删除}</code></pre><h2 id="3-4-非变动性函数"><a href="#3-4-非变动性函数" class="headerlink" title="3.4 非变动性函数"></a>3.4 非变动性函数</h2><h3 id="3-4-1-获取线性表当前元素个数"><a href="#3-4-1-获取线性表当前元素个数" class="headerlink" title="3.4.1 获取线性表当前元素个数"></a>3.4.1 获取线性表当前元素个数</h3><pre><code>//获取线性表当前元素个数template&lt;class DataType&gt;int SeqList&lt;DataType&gt;::GetLength()const{    return length;}</code></pre><h3 id="3-4-2-获取线性表的最大容量"><a href="#3-4-2-获取线性表的最大容量" class="headerlink" title="3.4.2 获取线性表的最大容量"></a>3.4.2 获取线性表的最大容量</h3><pre><code>//获取线性表的最大容量template&lt;class DataType&gt;int SeqList&lt;DataType&gt;::GetMaxLength()const{    return maxLength;}</code></pre><h3 id="3-4-3-获取第-i-位置的元素并返回到elem中"><a href="#3-4-3-获取第-i-位置的元素并返回到elem中" class="headerlink" title="3.4.3 获取第 i 位置的元素并返回到elem中"></a>3.4.3 获取第 i 位置的元素并返回到elem中</h3><pre><code>//获取第i位置的元素，返回到elem中emplate&lt;class DataType&gt;Status SeqList&lt;DataType&gt;::GetData(int i,DataType &amp;elem)const{    //判断i是否合法    if(i&lt;1 || i&lt;length)        return RANGE_ERROR;    else        elem = data[i-1];    return SUCCESS;    // 三元表达式 i&lt;1 || i&lt;length? RANGE_ERROR:SUCCESS;}</code></pre><h2 id="3-5-插入函数"><a href="#3-5-插入函数" class="headerlink" title="3.5 插入函数"></a>3.5 插入函数</h2><h3 id="3-5-1-插入elem元素到线性表尾部"><a href="#3-5-1-插入elem元素到线性表尾部" class="headerlink" title="3.5.1 插入elem元素到线性表尾部"></a>3.5.1 插入elem元素到线性表尾部</h3><pre><code>//插入elem元素到线性表尾部template&lt;class DataType&gt;Status SeqList&lt;DataType&gt;::Insert(DataType &amp;elem){    //先判断线性表是不是满了，没满的话再进行下一步操作    if(length==maxLength)        return FAIL;    else{        //因为数组内排序是从0开始的，所以数组下标和长度是差1的        //假设数组长度5，那数组下标则是0，1，2，3，4         //那么在第5个位置也就是length位置插入即可        data[length]=elem;        length++;        return SUCCESS;    }}</code></pre><h3 id="3-5-2-插入elem元素到i位置"><a href="#3-5-2-插入elem元素到i位置" class="headerlink" title="3.5.2 插入elem元素到i位置"></a>3.5.2 插入elem元素到i位置</h3><pre><code>//插入elem元素到i位置template&lt;class DataType&gt;Status SeqList&lt;DataType&gt;::Insert(int i , DataType &amp;elem){    //先判断i位置是否合法，再判断表是否满了，以上条件都不满足则可以插入    //满足 1&lt;=i&lt;=length    if(1&lt;=i || i&lt;length)        return RANGE_ERROR;//越界错误    else if(length == maxLength)        return FAIL;    else{        //插入元素，元素i位置以后的元素都往后挪        //元素是从最后一个开始往后挪        //删除和插入都是使用 j 和j-1这样的方式来表达元素前后关系，因为数组是从0开始的，循环次数都是要-1        for(int j=length; j&gt;=i;j--)            data[j]=data[j-1];        data[i-1]=elem;        length++;        return SUCCESS;    }}</code></pre><h2 id="3-6-删除函数"><a href="#3-6-删除函数" class="headerlink" title="3.6 删除函数"></a>3.6 删除函数</h2><h3 id="3-6-1-删除-i-位置的元素"><a href="#3-6-1-删除-i-位置的元素" class="headerlink" title="3.6.1 删除 i 位置的元素"></a>3.6.1 删除 i 位置的元素</h3><pre><code>//删除位置i的元素template&lt;class DataType&gt;Status SeqList&lt;DataType&gt;::Delete(int i){    //判断i位置是否合法    if( i&lt;1 || i&lt;length)        return RANGE_ERROR;    else{        //删除元素是i位置以后的元素往前挪        for(int j = i; j&lt;=length;j++)            data[j-1]=data[j];        length--;        return SUCCCESS;    }}</code></pre><h3 id="3-6-2-删除表内所有-elem的元素"><a href="#3-6-2-删除表内所有-elem的元素" class="headerlink" title="3.6.2 删除表内所有==elem的元素"></a>3.6.2 删除表内所有==elem的元素</h3><pre><code>//删除表内所有==elem的元素emplate&lt;class DataType&gt;Status SeqList&lt;DataType&gt;::DeleteEqualValue(DataType &amp;elem){    //遍历整个数组,判断里面的元素是否==elem，判断就删除    for(int i=0;i&lt;length;i++){        //判断元素是否==elem        if(data[i]==elem){            for(int j = i;j&lt;length;j++)                data[j]=data[j+1];            length--;        }    }    return SUCCESS;}</code></pre><h1 id="四、-线性表链式存储实现"><a href="#四、-线性表链式存储实现" class="headerlink" title="四、 线性表链式存储实现"></a>四、 线性表链式存储实现</h1><p>链式存储要链表实现，首先先定义结点类型：</p><h2 id="4-1-链表内结点类型"><a href="#4-1-链表内结点类型" class="headerlink" title="4.1 链表内结点类型"></a>4.1 链表内结点类型</h2><pre class=" language-c++"><code class="language-c++">template<class DataType>struct Node{public:    DataType *data;     //数据域    Node<DataType> *next//指针域    Node(){        data=0;        next=NULL;    }//结点的构造函数}</code></pre><h2 id="4-2-链表类体结构"><a href="#4-2-链表类体结构" class="headerlink" title="4.2 链表类体结构"></a>4.2 链表类体结构</h2><p>线性表类需要实现头节点和表长度，所以类体成员要有结点成员和int成员</p><pre><code>template&lt;class DataType&gt;class LinkList(){private:    Node&lt;DataType&gt; *head;        //头节点    int length;                   //表长public:    LinkList();    ~LinkList();    void display();        //遍历链表    int GetLength();    //获取该线性表的长度    int LocateData(const DataType&amp; data)const;        //定位元素位置    Status GetData(int i, DataType&amp; data)const;        //定位i位置，而后将i位置的元素返回给data    Status InsertElemAtIndex(int i, const DataType&amp; data);    //插入data元素到i位置    Status Insert(const DataType&amp; data);                    //将data元素插入到尾部    Status DeleteElemAtIndex(int i, DataType&amp; data);        //删除数据域为data的结点}</code></pre><h2 id="4-2-构造函数"><a href="#4-2-构造函数" class="headerlink" title="4.2 构造函数"></a>4.2 构造函数</h2><pre><code>//构造函数template&lt;class DataType&gt;LinkList&lt;DataType&gt;::LinkList(){    head = new Node&lt;DataType&gt;;    head-&gt;data=0;    head-&gt;next=NULL;    length=0;}</code></pre><h2 id="4-3-析构函数"><a href="#4-3-析构函数" class="headerlink" title="4.3 析构函数"></a>4.3 析构函数</h2><pre><code>//析构函数template&lt;class DataType&gt;LinkList&lt;DataType&gt;::~LinkList(){    delete head;}</code></pre><h2 id="4-4-非变动性函数"><a href="#4-4-非变动性函数" class="headerlink" title="4.4 非变动性函数"></a>4.4 非变动性函数</h2><h3 id="4-4-1-遍历链表"><a href="#4-4-1-遍历链表" class="headerlink" title="4.4.1 遍历链表"></a>4.4.1 遍历链表</h3><pre><code>//遍历链表template&lt;class DataType&gt;void LinkList&lt;DataType&gt;::display(){    Node&lt;DataType&gt; *p = head-&gt;next;    while(p!=NULL){        cout &lt;&lt; p-&gt;data &lt;&lt; " ";        p=p-&gt;next;    }}</code></pre><h3 id="4-4-2-获取该线性表的长度"><a href="#4-4-2-获取该线性表的长度" class="headerlink" title="4.4.2 获取该线性表的长度"></a>4.4.2 获取该线性表的长度</h3><pre><code>//获取该线性表的长度template&lt;class DataType&gt;int LinkList&lt;DataType&gt;::GetLength(){    return length;}</code></pre><h3 id="4-4-3-定位元素位置"><a href="#4-4-3-定位元素位置" class="headerlink" title="4.4.3 定位元素位置"></a>4.4.3 定位元素位置</h3><pre><code>//定位元素位置template&lt;class DataType&gt;int LinkList&lt;DataType&gt;::LocateData(const DataType &amp;data)const{    int count =1;    Node&lt;DataType&gt; *p = head-&gt;next;    while(p!=NULL){        if(p-&gt;data==data)            return count;        count++;        p=p-&gt;next;    }    if(p==NULL)        return 0; //找不到该元素}</code></pre><h3 id="4-4-4-定位-i-位置并将i位置的元素返回给data"><a href="#4-4-4-定位-i-位置并将i位置的元素返回给data" class="headerlink" title="4.4.4 定位 i 位置并将i位置的元素返回给data"></a>4.4.4 定位 i 位置并将i位置的元素返回给data</h3><pre><code>//定位i位置，然后将i位置的元素返回给datatemplate&lt;class DataType&gt;Status LinkList&lt;DataType&gt;::GetData(int i , DataType &amp;data)const{    //判断i位置是否合法    if( i&lt;1 || i&lt;length)        return RANGE_ERROR;    else{            Node&lt;DataType&gt; *p = head-&gt;next;        for(int couunt = 1;count&lt;i;i++)            p=p-&gt;next;        data=p-&gt;data;        return SUCCESS;        }}</code></pre><h2 id="4-5-插入函数"><a href="#4-5-插入函数" class="headerlink" title="4.5 插入函数"></a>4.5 插入函数</h2><h3 id="4-5-1-插入-data-元素到-i-位置"><a href="#4-5-1-插入-data-元素到-i-位置" class="headerlink" title="4.5.1 插入 data 元素到 i 位置"></a>4.5.1 插入 data 元素到 i 位置</h3><pre><code>//插入data元素到i位置template&lt;class DataType&gt;Status LinkList&lt;DataType&gt;::InsertElemAtIndex(int i , const DataType &amp;data){    //判断i位置的合法性    if( i&lt;1 || i&lt;=length)        return RANGE_ERROR;    else{        //定位到i-1的位置，然后修改i-1的元素后继为i+1        //然后释放i位置的结点        Node&lt;DataType&gt; *p =head-&gt;next;        for(int j = 1; j &lt; i-1 ; j++)            p=p-&gt;next;        //构造新结点        Node&lt;DataType&gt; *x= new Node&lt;DataType&gt;        x-&gt;data = data;//数据域等于传进来的data        x-&gt;next=p-&gt;next;//新节点的next== i-1元素的next        p-&gt;next = x;    // i-1元素的next 变成新节点        length++;        return SUCCESS;    }}</code></pre><h3 id="4-5-2-插入data元素到尾部"><a href="#4-5-2-插入data元素到尾部" class="headerlink" title="4.5.2 插入data元素到尾部"></a>4.5.2 插入data元素到尾部</h3><pre><code>//将data元素插入到尾部template&lt;class DataType&gt;Status LinkList&lt;DataType&gt;::Insert(const DataType &amp;data){    Node&lt;DataType&gt; *p = head;    //考虑到这个时候是空表，如果==head-&gt;next的话就出错了    Node&lt;DataType&gt; *x = new Node&lt;DataType&gt;;    x-&gt;data = data;    x-&gt;next = NULL;    //因为p指针是指向head的而不是head-&gt;next，所以循环变量从0开始    //如果是空表的话，length==0，循环条件不成立也不会执行循环体语句还是指向head本身    //如果不是空表，那么条件成立就会一直往下走    for(int count = 0; cout &lt; this-&gt; length ; count++)        p=p-&gt;next;    p-&gt;next = x;    length++    return SUCCESS;}</code></pre><h2 id="4-6-删除函数"><a href="#4-6-删除函数" class="headerlink" title="4.6 删除函数"></a>4.6 删除函数</h2><h3 id="4-6-1-删除-i-位置的结点并将元素值返回到-data"><a href="#4-6-1-删除-i-位置的结点并将元素值返回到-data" class="headerlink" title="4.6.1 删除 i 位置的结点并将元素值返回到 data"></a>4.6.1 删除 i 位置的结点并将元素值返回到 data</h3><pre><code>//删除i位置的结点，并将元素值返回到datatemplate&lt;class DataType&gt;Status LinkList&lt;DataType&gt;::DeleteElemAtIndex(int i,DataType &amp;data){   //判断i位置是否合法 1&lt;=i&lt;=length    if (i &lt; 1 || i &gt;length)        return RANGE_ERROR;    else {        Node&lt;DataType&gt;* p = head-&gt;next;        for (int count = 1;count &lt; i - 1;count++)            p = p-&gt;next;        Node&lt;DataType&gt;* q = p-&gt;next;  //指向i位置的结点        p-&gt;next = p-&gt;next-&gt;next;    //i-1位置的next指针指向 i+1结点        data = q-&gt;data;        //赋值给data带出去        delete q;        length--;        return SUCCESS;}</code></pre><p>后续会有双向链表和循环链表的代码！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象设计原则及模板方法模式</title>
      <link href="/2020/03/17/mian-xiang-dui-xiang-she-ji-yuan-ze/"/>
      <url>/2020/03/17/mian-xiang-dui-xiang-she-ji-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><p>设计模式都遵守面向对象设计原则，如果设计模式没有遵守面向对象设计原则的话，那么这个设计模式是有缺陷的，不完整的。这些设计原则非常重要，贯穿了所有的设计模式，而面向对象设计原则有包括：</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><ul><li>高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象。抽象不应该依赖于实现细节，而实现细节应该依赖于抽象（稳定）。</li></ul><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><ul><li>对扩展开发，对更改封闭。类模块应该是可扩展的，但是不可修改。<blockquote><p>在类内增加扩展功能来应对需求的变化。</p></blockquote></li></ul><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><ul><li>一个类应该仅有一个引起它变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ul><li>子类必须能够替换它们的基类。</li><li>继承表达类型抽象。</li></ul><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><ul><li>不应该强迫客户程序依赖它们不用的方法。</li><li>接口应该小而完备。</li></ul><h2 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h2><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li><li>而对象组合则只要被组合的对象具有良好定义的接口，耦合度低。</li></ul><h2 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h2><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。</li></ul><h2 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h2><ul><li>使用封装来创建对象之间的分解层，让设计者可以在分解层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合</li></ul><blockquote><p>需要对代码里面的类和对象之间的关系有一个重新的认识，知道哪些代码是稳定的，哪些是变化的，</p></blockquote><h1 id="设计模式模式分类"><a href="#设计模式模式分类" class="headerlink" title="设计模式模式分类"></a>设计模式模式分类</h1><p>设计模式的要点是在“寻找变化点，然后在变化点处应用设计模式，从而更好地来应对需求的变化”。“什么时候、什么地点应用设计模式” 比 “理解设计模式结构本身”更为重要，设计模式的应用不宜先入为主一上来就使用设计模式，这样是对设计模式的最大误用，避免过度使用设计模式，没有一步到位的设计模式。而是要在变化的地方使用设计模式，而难点是怎么区分整个系统中哪一些是稳定的部分，哪一些是变化的地方。</p><p>从目的来看：</p><ul><li>创建型模式：讲对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。</li><li>结构性模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。</li><li>行为型模式：通过类继承或者对象组合划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。</li></ul><p>从范围来看:</p><ul><li>类模式处理类与子类的静态关系。</li><li>对象模式处理对象间的动态关系。</li></ul><hr><h2 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法 Template Method"></a>模板方法 Template Method</h2><p>template method是一种非常基础的设计模式，在面向对象系统中有者大量的应用。它用最简洁的机制（虚函数的多态性），为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</p><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个操作中的算法的骨架（稳定），而将一些步骤（变化）<code>延迟到子类</code>中。template Method 使得子类可以不改变一个算法（复用）的结构即可重定义（override 重写）该算法的某些特定步骤。</p><h3 id="在什么时候会用到-Template-Method-模式"><a href="#在什么时候会用到-Template-Method-模式" class="headerlink" title="在什么时候会用到 Template Method 模式"></a>在什么时候会用到 Template Method 模式</h3><p>在软件构建过程中，对于某一项任务，它常常有<code>稳定</code>的整体操作结构，但完成整个任务的各个子步骤却有很多<code>改变的需求</code>或者在编码中还没有确定如何实现，而<code>无法和任务的整体结构同时实现</code>，必定会出现一个早一个晚的问题。<br>那么如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求呢？这时候就可以使用 tempatle method模板方法这个设计模式了。下面就要一个示例来演示一下：</p><pre class=" language-c++"><code class="language-c++">/*假设现在有2个团队，一个是框架开发人员，一个是应用程序APP开发人员；框架开发团队定义了一个框架，框架中有一个算法 run()并且定义了5个子步骤，子步骤分别为step1、step2、step3、step4、step5，其中setp1、step3、step5都已经由框架开发团队实现，step2、step4由APP团队实现。如果没有使用 Template Method设计模式：*/// 框架开发人员写的代码class Library{public:    void setp1(){   /....  }  //表示已经实现了函数体    void setp3(){   /....  }    void setp5(){   /....  }};//APP开发人员class Application{public:    void setp2(){   /.... }    void setp4(){   /.... }}int main(){    Library lib();    Application app();    //执行算法    lib.setp1();    app.setp2();    lib.setp3();    app.setp4();    lib.setp5();    return 0;}</code></pre><p>​     在上面的代码上可以看出，2个团队分别负责算法中的一部分子步骤，而main方法里面的执行步骤就是就是我们说的这个算法的稳定操作结构（setp1 ~ setp5），但是分工给2个团队必定有一个团队出于某种原因是晚些时候写完的，在晚些写完的团队还要兼顾写main函数里面的操作结构。现在来看使用了 TemplateMethod模板方法设计模式的代码会是什么样：</p><pre class=" language-c++"><code class="language-c++">class Library{public:    void run(){        setp1();        setp2();        setp3();        setp4();        setp5();    }    virtual ~Library(){ }protected:    void setp1(){    //...}    void setp3(){    //...}    void setp5(){    //...}    virtual void setp2() = 0;  //需要子类实现的纯虚方法    virtual void setp4() = 0;};//app开发类class Application: public Library{protected:    virtual void setp2(){   //...} //子类重写实现    virtual void setp4(){   //...} //子类重写实现};  //主函数int main(){    Library* pLib = new Applicaton();    //基类指针指向子类对象，调用虚函数    pLib.run();            //run函数不是虚函数，是public声明的，所以子类可以调用    //而run函数里面调用的不都是基类的，有子类的实现的函数，这时候调用的就是虚函数    delete pLib;    return 0;}</code></pre><p>在代码中可以看出，原本在第一个例子中要在main方法中实现的算法逻辑被实现到了框架类中的run算法中，在<code>Library</code>类中声明了<code>run</code>算法所需要的5个子步骤方法，自己能实现的全部写好，而不能实现的声明成纯虚函数，等待子类方法继承并实现它，<code>Application</code>子类继承自<code>Library</code>基类，对自己要实现的 setp2和setp4进行重写实现，而后在<code>main</code>函数里面，声明基类指针并且这个指针指向的是子类对象，这样配合配合虚函数来实现多态，指针再进行调用基类<code>public声明 run()</code>方法，在<code>run</code>方法中实现了setp1~setp5的子步骤，其中setp2和setp4会调用自己的虚函数来执行，这样就完成了多态的实现。</p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><p>TemplateMethod牧师是一种 非常基础性的设计模式，在抽象系统中有着大量的应用。用最简便的模式（虚函数的多态应用）为很多应用程序框架提供了灵活的扩展点，实现代码复用用方面来实现结构。</p><p>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是TemplateMethod的典型应用。</p><p>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法，纯虚函数），但一般推荐将它们设置为protected方法，可以被子类继承也不暴露接口。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序存储-数组的变动性操作原理</title>
      <link href="/2020/03/07/shu-zu-nei-yuan-su-de-bian-dong-xing-cao-zuo-yuan-li-xiang-jie/"/>
      <url>/2020/03/07/shu-zu-nei-yuan-su-de-bian-dong-xing-cao-zuo-yuan-li-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序存储方式内-数组的变动性操作"><a href="#顺序存储方式内-数组的变动性操作" class="headerlink" title="顺序存储方式内-数组的变动性操作"></a>顺序存储方式内-数组的变动性操作</h1><p>  所有变动性的操作分为4大方面：增（ADD）、删（Delete）、改（Update）、查（query）。下面对这4方面的操作进行一些分析，帮助自己理解原理，回头看时更容易想起。</p><h2 id="一、增加元素（ADD）"><a href="#一、增加元素（ADD）" class="headerlink" title="一、增加元素（ADD）"></a>一、增加元素（ADD）</h2><p>  增加元素可以也就是插入元素，插入的位置也可以概括为3类：从头部插入、从中间位置插入、从尾部插入。这3部分除了从尾部插入，其余2部分插入元素势必会引起其他元素的移动，2者差别就是被移动元素的多少而已。头部插入就是数组全部元素往后挪一个位置，在数组任意一个位置 <code>i</code> 插入元素，那么 <code>i</code> 位置往后的元素都得往后挪位置，<code>i</code> 之前的元素不会受影响。</p><p>初始化一个数组，对数组内元素分别进行赋值：</p><pre><code>int array[10] = {1,2,3,4,5,6,7,8};</code></pre><p>现在在数组内<code>i</code> 位置插入一个元素10，<code>i</code>位置之后的元素往后挪，假设要在第三个位置插入一个元素10，那么第三个位置的元素就要往后挪位置了，但是挪动的次序并不是第三个位置的元素挪，而是最后一个元素开始挪，效果如图:</p><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E5%90%91%E5%90%8E%E6%8C%AA%E5%8A%A8%E4%BD%8D%E7%BD%AE2-gif%E5%8A%A8%E7%94%BB.gif" alt=""></p><p>  在上图中可以看出，假设我们在数组第3个位置插入元素10，数组内下标为7的元素被挪到下标8，下标6元素被挪动下标7，以此类推直到下标2位置的元素被挪到下标3，下标2被空出来，元素10被插入进来。<code>设被挪动元素的位置为 z ，那么他们的挪动规律总是为： z + 1 = z</code> , <code>z</code> 位置的元素被赋值到 <code>z + 1</code> 的位置,也就是往后挪1步的位置。</p><p>  处理语句已经构想出来了，那么循环语句该怎么决定呢？在数组内位置 <code>i</code> 插入元素，数组内就要向后挪动元素来空出一个位置，而向后挪动元素的动作是从最后一个元素开始的，这样才会保证数组内的元素保持原样。如果是 <code>i+1</code> 个元素开始往后挪的话，那么元素就会被覆盖而且会一直复制，到最后 <code>i</code> 位置后面的元素全是 <code>i+1</code> 元素的副本。</p><p>控制for循环的控制语句有2种类型，一个是递增，从小到大；另一种则是递减，从大到小：</p><pre><code>    for(int i = 0 ; i&lt;=10; i++)  //0-10 循环10次    for(int i = 10 ; i &gt;= 0 ; i--)  //10-0 循环10次</code></pre><p>  for循环次数就是被挪动元素的个数，也就是 <code>i</code> 位置元素到最后一个元素的距离往后挪元素都是从最后一个元素开始挪的，然后递减，直到 i 位置为止；for循环无论是采用递增或者是递减的方式，其中有一头必定是插入元素位置 <code>i</code> ，另一头就是该数组最后一个元素的下标。</p><p>  现在我写了一个函数专门来获取数组的长度，代码如下：</p><pre><code>int ArrayLength(int a[]) {    int length=0;    for (int i = 0; ; ++i) {        if (a[i] != 0) length++;        else            break;    }        return    length;}</code></pre><p>  声明一个length变量用来记录数组长度，设置一个for循环，该循环没有做判断表达式，所以这个循环是死循环，在判断内设置一个if判断，如果数组内的元素不等于0的时候，length自增，若元素==0时则break，退出循环，然后返回最后一次自增的length。</p><p>  有了数组长度之后就好做循环了，当然计算数组长度的函数也可以定义在插入函数里面，在数组内 <code>i</code> 位置插入元素的函数的写法：</p><pre><code>void  Insert( int a[] , int i , int value , int length){    //这里要做 数组空间是否足够的判断和 插入位置 i 是否在 1 ~ length+2 的区间内的判断    //我这里省略了这2步做法    for( int j = length ; j &gt;= i ; j--){        a[j] = a[j-1] ; //将元素往后挪，第一轮循环，J是最后一个元素的下标+1    }    a[i-1] = value;     // 数组的排序是从0开始的，所以 i位置元素的下标表示是 i-1    //从头部插入则 i 位置换成1即可。}</code></pre><h2 id="二、删除元素（Delete）"><a href="#二、删除元素（Delete）" class="headerlink" title="二、删除元素（Delete）"></a>二、删除元素（Delete）</h2><p>  删除元素表示从 <code>i</code> 位置把元素删除，然后 <code>i</code> 位置后面的元素全部往前挪一步，如果要删除第三个位置的元素，那么从第4个位置的元素开始就要往前挪一个位置，效果如下：<br><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E5%90%91%E5%89%8D%E6%8C%AA%E5%8A%A8%E4%BD%8D%E7%BD%AE-gif%E5%8A%A8%E7%94%BB.gif" alt=""></p><p>这时候就不能使用递减的方式来控制循环了，使用递增方式，初始表达式是<code>i</code>位置，终点是数组最后一个元素下标：</p><pre><code>//这里为了方便显示直接传元素下标进去，不穿元素值，如果传元素值也就是遍历一遍数组，记录元素值的下标在进行for循环操作即可。void Delete( int a[], int i ,int length){  for(int j = i; i&lt;= length; j++){    a[j-1]=a[j];  }  a[length-1]=0;}</code></pre><h2 id="三、修改元素（Update）和查找元素（query）"><a href="#三、修改元素（Update）和查找元素（query）" class="headerlink" title="三、修改元素（Update）和查找元素（query）"></a>三、修改元素（Update）和查找元素（query）</h2><p>  修改元素与查找元素本质上操作是一样的，二者区别在于修改元素操作比查找元素操作多了一步修改值而已。首先遍历整个数组，在遍历每一个元素的时候需要拿要查找或者修改的元素一一与数组元素相比较，若元素相等，查找则返回该元素的下标，修改则该元素修改为修改后的元素的。下面给出2个操作的代码：</p><pre><code>bool Update( int a[], int i , int value){    for( int j = 0 ; j&lt;= ArrayLength(a); j++){        if(a[j]==i){            a[j]=value;            return true;        }    }    return flase;}#diint Query(int a[],int value){    for(int j = 0 ; j&lt;= ArrayLength(a);j++){        if(a[j]==i){            return j;        }    }    return -1;}</code></pre><blockquote><p>上述代码都是比较简单的数组实现，根据需求的不同来写代码</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL 各种容器</title>
      <link href="/2020/03/01/c-stl-ge-chong-rong-qi/"/>
      <url>/2020/03/01/c-stl-ge-chong-rong-qi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习自侯捷老师的 《The C++ Standard Library》中文翻译版</p></blockquote><h1 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h1><p>  容器用来管理一组元素，在STL中提供不少类型的容器，总的来说容器分为2大类：<code>序列式容器</code>和<code>关联式容器</code>2种。<br>  <code>序列式容器</code>是一个 <strong>可序</strong> 群集，容器内所有的元素都是由固定位置的，所存放的位置取决于插入时机和地点，和元素值无关。以追加的方式对容器插入多个元素，这些元素的排序次序和插入次序一致。STL中预定义好的序列式容器由 <code>vector</code>、<code>deque</code>、<code>list</code>。</p><p>  关联式容器是个 <strong>已序</strong> 群集，容器内所有的元素位置取决于特定的排序准则，有STL定好的准则，用户也可以根据需求来指定排序准则，与插入的元素值无关，只关注排序准则来进行排序，这一点和序列式不同。STL提供的关联式容器有：<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/QQ%E5%9B%BE%E7%89%8720200228104801.png" alt=""></p><h1 id="二、vector容器"><a href="#二、vector容器" class="headerlink" title="二、vector容器"></a>二、vector容器</h1><h2 id="vector的构造函数和析构函数"><a href="#vector的构造函数和析构函数" class="headerlink" title="vector的构造函数和析构函数"></a>vector的构造函数和析构函数</h2><p>  下面列出了vector容器所有的构造函数和析构函数</p><pre><code>vector&lt; Elem &gt; c   //构造一个空vectorvector&lt; Elem &gt; c{1,2,3,4,5};    //构建元素初值为1，2，3，4，5的vectorvector&lt; Elem &gt; c1(c2)   //根据c2来构造一个c1，所有元素都会被拷贝vector&lt; Elem &gt; c(n)     //生成一个大小为n的vectorvector&lt; Elem &gt; c(n,elem)    //生成一个大小为n，每个元素都是elem的vectorvector&lt; Elem &gt; c(bengin,end)    //生成一个vector，区间begin和end之间的元素做为元素初值c.~vector&lt; Elem &gt;()     //执行析构函数，销毁所有元素</code></pre><h2 id="vector的公共函数"><a href="#vector的公共函数" class="headerlink" title="vector的公共函数"></a>vector的公共函数</h2><p>  所有容器都会提供的一些公共函数：</p><pre><code>size();     //返回当前容器的元素数量empty();    //判断当前容器是否还有元素，有元素就返回falsemax_size(); //返回容器所能容量的最大元素数量</code></pre><blockquote><p>如果元素数量超过容器最大元素数量，vector会乘2倍增长<br>比如：如果容器容量为4，插入元素5个，那当前最大容器容量变成8，以此类推。</p></blockquote><p>vector提供像数组一样的[]方式来元素赋值操作</p><pre><code>c.at(idx)       //返回索引idx所表示的元素c[idx]          //返回索引idx的元素c.front()       //返回第一个元素c.back()        //返回最后一个元素</code></pre><h2 id="vector的插入元素函数、修改元素函数和移除元素的函数"><a href="#vector的插入元素函数、修改元素函数和移除元素的函数" class="headerlink" title="vector的插入元素函数、修改元素函数和移除元素的函数"></a>vector的插入元素函数、修改元素函数和移除元素的函数</h2><pre><code>c.insert(pos,elem)      //在pos位置上插入一个elem副本，pos是一个迭代器c.insert(pos,n,elem)    //在pos位置上插入n个elem副本c.insert(pos,begin,end) //在pos位置上插入区间[begin，end]内所有的元素副本c.push_back(elem)       //在尾部插入一个elem元素c.erase(pos)            //移除pos位置上的元素c.erase(begin,end)      //移除begin-end区间上的元素c.clear()               //移除所有元素，将容器清空</code></pre><blockquote><p>注意：vector容器在后端插入和删除元素的性能特别高，但是在中间插入删除的话，后面的元素就会产生移动，+1或者-1。    </p></blockquote><p>  vector没有提供可以直接移除“等于某值”的元素，这一步可以使用 <code>remove()</code> 算法来实现，有2个方法可以实现</p><pre><code>删除的值 = val1、使用remove()算法，然后根据remove()算法返回的新终点，遍历容器。vector&lt;int&gt; coll;for (int i = 0; i &lt; 5;++i) {        coll.push_back(i);    }cout &lt;&lt; "value:";vector&lt;int&gt;::iterator pos;//remove算法返回一个终点赋值给end迭代器。vector&lt;int&gt;::iterator end =    remove(coll.begin(), coll.end(), 2);        cout &lt;&lt; "\nvalue:";    //使用新终点结合begin()遍历容器。    for (pos = coll.begin();pos != end;++pos) {        cout &lt;&lt; *pos &lt;&lt; " ";    }2、erase()算法和remove()算法一起使用coll.erase(remove(coll.begin(),coll.end(),val),coll.endl());</code></pre><h2 id="vector函数运用示例"><a href="#vector函数运用示例" class="headerlink" title="vector函数运用示例"></a>vector函数运用示例</h2><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){vector&lt;int&gt; c1; //创建一个int类型的vector容器，起名为c1    vector&lt;int&gt;::iterator pos; //船舰一个int类型vector容器的迭代器，起名为pos    //给vector容器内添加元素    c1.push_back(2);    c1.push_back(4);    c1.push_back(3);    c1.push_back(6);    c1.push_back(9);    c1.push_back(1);    c1.push_back(5);    c1.push_back(7);    c1.push_back(8);    cout &lt;&lt; "size(): " &lt;&lt; c1.size() &lt;&lt; endl;    cout &lt;&lt; "max_size(): " &lt;&lt; c1.max_size() &lt;&lt; endl;    cout &lt;&lt; "front(): " &lt;&lt; c1.front() &lt;&lt; endl;    cout &lt;&lt; "back(): " &lt;&lt; c1.back() &lt;&lt; endl;    pos = min_element(c1.begin(), c1.end());  // 调用全局函数 min_element()，需要传入一个容器的一个区间，用于找出该区间内最小的一个数值    cout &lt;&lt; "c1容器内最小的数值是：" &lt;&lt; *pos &lt;&lt; endl;  // 在迭代器左边加上星号是取该迭代器所指向的值    pos = max_element(c1.begin(), c1.end());  //调用全局函数 max_element()，传入容器的一个区间，找出最大值并让迭代器指向该值    cout &lt;&lt; "c1容器内最大的数值是：" &lt;&lt; *pos &lt;&lt; endl;    //使用sort算法来对c1容器内的数值进行排序,默认是从小大的排序    sort(c1.begin(), c1.end());    for (pos = c1.begin(); pos != c1.end(); ++pos) {        cout &lt;&lt; *pos &lt;&lt; " ";    }    return 0;}输出：     size(): 9max_size(): 1073741823front(): 2back(): 8c1容器内最小的数值是：1c1容器内最大的数值是：91 2 3 4 5 6 7 8 9</code></pre><h1 id="三、deque容器"><a href="#三、deque容器" class="headerlink" title="三、deque容器"></a>三、deque容器</h1><p>  deque容器与vector容器都属于序列式容器，提供随机存取元素的功能，且比vector容器多提供了一个头部插入函数，vector容器有中间插入函数（insert（））和尾部插入函数（push_back（））函数，deque容器多了一个 <code>push_fornt()</code> 函数，提供头部插入元素的功能。</p><p>  deque容器与vector容器一样，在中间部分安插元素和移除元素的速度相对较慢，因为所有元素都需要移动来腾出或者填补空间；迭代器属于 <code>random access iterator 随机存取迭代器</code> ,除开上述几点， vector容器与deque容器的接口几乎一致，两者都可尝试。<br><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/20200303204704.png" alt=""></p><h2 id="deque容器的构造函数与析构函数"><a href="#deque容器的构造函数与析构函数" class="headerlink" title="deque容器的构造函数与析构函数"></a>deque容器的构造函数与析构函数</h2><pre><code>deque&lt; Elem &gt; c   //构造一个空dequedeque&lt; Elem &gt; c{1,2,3,4,5};    //构建元素初值为1，2，3，4，5的dequedeque&lt; Elem &gt; c1(c2)   //根据c2来构造一个c1，所有元素都会被拷贝deque&lt; Elem &gt; c(n)     //生成一个大小为n的dequedeque&lt; Elem &gt; c(n,elem)    //生成一个大小为n，每个元素都是elem的dequedeque&lt; Elem &gt; c(bengin,end)    //生成一个vector，区间begin和end之间的元素做为元素初值c.~deque&lt; Elem &gt;()     //执行析构函数，销毁所有元素</code></pre><h2 id="deque容器的插入元素函数、删除元素函数"><a href="#deque容器的插入元素函数、删除元素函数" class="headerlink" title="deque容器的插入元素函数、删除元素函数"></a>deque容器的插入元素函数、删除元素函数</h2><pre><code>c1 = c2              //将C2的所有元素赋值给C1c.assign(n,elem)    //将n个elem副本赋值给cc.assign(begin,end)    //将区间begin-end内的元素赋值给cc1.swap(c2)            //将c1和c2的元素呼唤swap(c1,c2)            //同上c.insert(pos,elem)    //将elem插入到pos位置，原先的元素往后移位置c.insert(pos,n,elem)    //将n个elem插入到pos位置，原先的元素往后移n个位置c.insert(pos,begin,end)    //将区间begin-end内的元素插入到pos位置内c.push_front(elem)    //将elem插入到头部c.pop_front()        //删除头部元素c.push_back(elem)    //将elem插入到尾部c.pop_back()        //删除尾部元素c.erase(pos)        //删除pos位置的元素，注意后面元素会进行覆盖，容器总个数并不会变c.erase(begin,end)    //删除区间内的元素，返回下一个元素的位置c.clear()            //清除所有元素</code></pre><h2 id="deque容器的非变动函数"><a href="#deque容器的非变动函数" class="headerlink" title="deque容器的非变动函数"></a>deque容器的非变动函数</h2><pre><code>c.size();     //返回当前容器的元素数量c.empty();    //判断当前容器是否还有元素，有元素就返回falsec.max_size(); //返回容器所能容量的最大元素数量c.at(idx)      //返回索引idx所指的元素c[idx]          //与数组操作一样</code></pre><hr><h1 id="四、list容器"><a href="#四、list容器" class="headerlink" title="四、list容器"></a>四、list容器</h1><p>  list是使用双向链表来管理元素，内部结构和vector、deque完全不同：list不支持随机存取，如果要存第n个元素，那就要顺着串联爬过n-1给元素，所以在list中随机遍历元素是一个很缓慢的。但是在list的任何位置安插和删除元素都非常快，始终是常数时间完成，因为不需要移动任何元素，只需要进行一些指针操作而已。list有不少的成员函数来进行移动元素，相对于STL的同名算法，这些函数执行起来更快。<br><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/20200303204734.png" alt=""></p><h2 id="list的构造函数、析构函数"><a href="#list的构造函数、析构函数" class="headerlink" title="list的构造函数、析构函数"></a>list的构造函数、析构函数</h2><pre><code>list Elem &gt; c   //构造一个空listlist&lt; Elem &gt; c1(c2)   //根据c2来构造一个c1，所有元素都会被拷贝list&lt; Elem &gt; c(n)     //生成一个大小为n的listlist&lt; Elem &gt; c(n,elem)    //生成一个大小为n，每个元素都是elem的listlist&lt; Elem &gt; c(bengin,end)    //生成一个list，区间begin和end之间的元素做为元素初值c.~list&lt; Elem &gt;()     //执行析构函数，销毁所有元素</code></pre><h2 id="list的非变动性操作函数"><a href="#list的非变动性操作函数" class="headerlink" title="list的非变动性操作函数"></a>list的非变动性操作函数</h2><pre><code>c.size();     //返回当前容器的元素数量c.empty();    //判断当前容器是否还有元素，有元素就返回falsec.max_size(); //返回容器所能容量的最大元素数量</code></pre><h2 id="list容器插入元素函数、删除元素操作函数"><a href="#list容器插入元素函数、删除元素操作函数" class="headerlink" title="list容器插入元素函数、删除元素操作函数"></a>list容器插入元素函数、删除元素操作函数</h2><pre><code>c.insert(pos,elem)    //将elem插入到pos位置，原先的元素往后移位置c.insert(pos,n,elem)    //将n个elem插入到pos位置，原先的元素往后移n个位置c.insert(pos,begin,end)    //将区间begin-end内的元素插入到pos位置内c.push_front(elem)    //将elem插入到头部c.pop_front()        //删除头部元素c.push_back(elem)    //将elem插入到尾部c.pop_back()        //删除尾部元素c.renive(value)        //删除所有值为value的元素c.erase(pos)        //删除pos位置的元素，注意后面元素会进行覆盖，容器总个数并不会变c.erase(begin,end)    //删除区间内的元素，返回下一个元素的位置c.clear()            //清除所有元素//splice函数是list容器独有的函数，译为剪切c.splice(pos,c2)    //将c2容器内的所有元素 转移 到c容器的pos位置c.splice(pos,c2,c2pos)    //将c2容器内c2pos所指的元素转移到c容器pos迭代器所指的位置上c.splice(pos,c2,c2begin,c2end)    //将c2容器的begin-end区间元素转移到c容器pos迭代器所指的位置//list容器的一些辅助函数c.unique()            //如果存在若干相邻而数值相等的元素，就移除重复元素，只留下一个，配合sort()函数排序使用c.merge(c2)            //假设c1和c2容器都包含已序元素，将c2的所有元素转移到c，而且合并后的list仍未已序状态</code></pre><blockquote><p>如果想要删除某一个指定的值元素，可以先用 find算法来找到那个元素，并赋值给一个迭代器，再用remove函数删除。</p></blockquote><h2 id="list容器函数示例"><a href="#list容器函数示例" class="headerlink" title="list容器函数示例"></a>list容器函数示例</h2><pre><code>void printList(const list&lt;int&gt;&amp; left, const list&lt;int&gt;&amp; right) {    cout &lt;&lt; "list1 :";    ostream_iterator&lt;int&gt; out(cout, " ");    copy(left.begin(),left.end(),out);    cout &lt;&lt; endl &lt;&lt; "list2 :";    copy(right.begin(), right.end(), out);    cout &lt;&lt; endl &lt;&lt; endl;}//传入2个list列表输出list容器内的函数//主函数int main(){//创建2个list容器    list&lt;int&gt; list1, list2;    //向2个容器内添加元素    for (int i = 0; i &lt; 6;++i) {        list1.push_back(i);        list2.push_front(i);    }    //输出是  list1：0 1 2 3 4 5//              list2: 5 4 3 2 1 0    //输出元素    printList(list1, list2);    //list2函数调用splice函数，使用find函数查找vaule 3 ，将list1容器里所有的元素插入到list2 值3的迭代器前面    //splice函数用法，哪个容器调用的就是最终元素的接收者，实参里面的容器是被移动元素的容器。    //这里用法是将list1的元素插入到list2 元素值=3的地方的前面    //list2.splice(要转移到的位置迭代器，要被转移元素的容器)    /*输出是list1 :            list2 :5 4 0 1 2 3 4 5 3 2 1 0    */    list2.splice(find(list2.begin(), list2.end(), 3), list1);    printList(list1, list2);    //转移元素    //list2.splice(要转移到的位置迭代器，要转移到的容器，要被转移的位置迭代器);    /*输出是            list1 :            list2 : 4 0 1 2 3 4 5 3 2 1 0 5    */    list2.splice(list2.end(), list2, list2.begin());    printList(list1, list2);    //调用sort算法来进行排序，然后进行赋值操作    list2.sort();    list1 = list2;    list2.unique();//这步操作让list2的重复元素都去除掉了    printList(list1, list2);    //将list2的元素转移到list1，而且顺序保证是排序的，前提是list2容器内的元素要排序好    list1.merge(list2);    list&lt;int&gt;::iterator pos = list1.begin();    printList(list1, list2);    }</code></pre><hr><h1 id="五、set和multiset容器"><a href="#五、set和multiset容器" class="headerlink" title="五、set和multiset容器"></a>五、set和multiset容器</h1><p>  set和multiset这2个容器属于关联式容器，关联式容器是根据特定的排序准则，自动的将元素排序，这2个容器不同处是在multiset容器允许元素重复而set不允许元素重复。因为关联式容器是根据排序准则进行排序，那么像push_back和push_fronk这类函数就不能用了，因为插入尾部或者头部的话就破坏了关联式容器的准则-已序。<br><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/20200303204758.png" alt=""></p><p>  set容器是采用平衡二叉树的方式来完成，一个根节点，左节点是比根节点小，右节点比根节点大（目前还没学过数据结构，个人浅显理解），根据这一点插入元素时如果提供一个迭代器来给系统指定一个区域，这样插入速度会快很多</p><h2 id="set和multiset的构造函数和析构函数"><a href="#set和multiset的构造函数和析构函数" class="headerlink" title="set和multiset的构造函数和析构函数"></a>set和multiset的构造函数和析构函数</h2><pre><code>set Elem &gt; c   //构造一个空setset&lt; Elem &gt; c1(c2)   //根据c2来构造一个c1，所有元素都会被拷贝set&lt; Elem &gt; c(n)     //生成一个大小为n的setset&lt; Elem &gt; c(n,elem)    //生成一个大小为n，每个元素都是elem的setset&lt; Elem &gt; c(bengin,end)    //生成一个set，区间begin和end之间的元素做为元素初值c.~set&lt; Elem &gt;()     //执行析构函数，销毁所有元素//multiset与set的构造函数和析构函数一致//在创建容器时可以指定排序准则，若不指定默认是以升序准则来对容器内元素来排列//若想指定排序准则，比如以降序，则可以写为：    set&lt;int, greater&lt;int&gt;&gt; coll;    //产生一个降序排列的容器</code></pre><h2 id="set和multiset的非变动性函数"><a href="#set和multiset的非变动性函数" class="headerlink" title="set和multiset的非变动性函数"></a>set和multiset的非变动性函数</h2><pre><code>c.size();     //返回当前容器的元素数量c.empty();    //判断当前容器是否还有元素，有元素就返回falsec.max_size(); //返回容器所能容量的最大元素数量</code></pre><h2 id="set和multiset的元素插入函数、删除元素函数"><a href="#set和multiset的元素插入函数、删除元素函数" class="headerlink" title="set和multiset的元素插入函数、删除元素函数"></a>set和multiset的元素插入函数、删除元素函数</h2><pre><code>c.insert(elem)            //插入elem元素副本，并返回元素新位置c.insert(pos,elem)        //在pos位置插入elem元素副本，返回新位置c.insert(begin,end)        //将区间[begin,end]内的元素插入到cc.erase(elem)            //删除“与elem”相等的元素，并返回被移除元素的个数c.erase(pos)            //删除迭代器pos所指的元素c.erase(begin,end)        //删除区间[begin,end]内的所有元素c.clear()                //删除容器内所有的元素//在使用insert()函数来插入元素时，如果是set容器，set容器是不允许重复元素出现的，如果这个时候插入一个容器内已经存在的元素，新元素是插入不进去的，我们怎么判断新元素有没有成功插入呢？// set使用 pair&lt;iterator,bool&gt; insert( const value_type &amp; elem)// pair结构中的second成员表示元素类型是bool类型，值是否安插成功，true表示成功，false则失败// pair结构中的first成员则返回新元素的位置，或者返回现存的同值的位置。// 举例：pair&lt;set&lt;int, greater&lt;int&gt;&gt;::iterator, bool&gt; status = coll.insert(4);    //根据.second元素的值来判断是否插入成功，true则插入成功，false表示插入失败    if (status.second) {        cout &lt;&lt; endl&lt;&lt;"元素插入成功"&lt;&lt; endl;    }    else {        cout &lt;&lt; "元素插入失败" &lt;&lt; endl;    }</code></pre><h2 id="特殊的搜寻函数"><a href="#特殊的搜寻函数" class="headerlink" title="特殊的搜寻函数"></a>特殊的搜寻函数</h2><p>  set和multiset在元素快速搜寻方面有优化设计，所以提供了特殊的搜寻函数，如果有搜寻需求，推荐使用同名的STL算法特殊版本：</p><pre><code>count(elem)                //返回“元素值==elem”的元素个数find(elem)                //返回“元素值==elem”的第一个元素，如果找不到就返回end()lower_bound(elem)        //返回elem的第一个可安插位置upper_bound(elem)        //返回elem的最后一个可安插位置equal_range(elem)        //返回elem可安插的第一个位置和最后一个位置</code></pre><h2 id="set和muliset函数示例"><a href="#set和muliset函数示例" class="headerlink" title="set和muliset函数示例"></a>set和muliset函数示例</h2><pre><code>set&lt;int, greater&lt;int&gt;&gt; coll;    //产生一个降序排列的容器    set&lt;int&gt; coll2;                    //默认是升序排列的容器    coll.insert(3);    coll.insert(2);    coll.insert(1);    coll2.insert(3);    coll2.insert(2);    coll2.insert(1);    cout &lt;&lt; "coll：";    copy(coll.begin(), coll.end(), ostream_iterator&lt;int&gt;(cout, " "));    cout &lt;&lt; endl &lt;&lt; "coll2：";    copy(coll2.begin(), coll2.end(), ostream_iterator&lt;int&gt;(cout, " "));    //插入一个元素，并声明一个对数变量的成员函数来判断元素是否插入成功    //pair函数有2个元素，一个是对应容器类型的迭代器，一个是bool类型，这是固定的。    pair&lt;set&lt;int, greater&lt;int&gt;&gt;::iterator, bool&gt; status = coll.insert(4);    //根据.second元素的值来判断是否插入成功，true则插入成功，false表示插入失败    if (status.second) {        cout &lt;&lt; endl&lt;&lt;"元素插入成功"&lt;&lt; endl;    }    else {        cout &lt;&lt; "元素插入失败" &lt;&lt; endl;    }    cout &lt;&lt; "coll：";    copy(coll.begin(), coll.end(), ostream_iterator&lt;int&gt;(cout, " "));</code></pre><h1 id="六、map和multimap容器"><a href="#六、map和multimap容器" class="headerlink" title="六、map和multimap容器"></a>六、map和multimap容器</h1><p>  map和multimap是一种字典结构，这2个容器的元素存储方式有些不同，插入的元素叫做pair的结构，这个结构由 <code>key / value</code> 组成，也就是 键值 / 实值，这2个容器对 <code>key</code> 的查询很快，但对 <code>value</code> 的查询却差强人意。set和multiset可以理解为特殊的map和multimap，只不过它们的 <code>key</code> 也就是 <code>value</code> 本身。map和mulitmap的不同之处也是在于是否能存储重复元素而已。<br><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/20200303205044.png" alt=""></p><h2 id="map和multip的构造函数和析构函数"><a href="#map和multip的构造函数和析构函数" class="headerlink" title="map和multip的构造函数和析构函数"></a>map和multip的构造函数和析构函数</h2><pre><code>map Elem &gt; c   //构造一个空mapmap&lt; Elem &gt; c1(c2)   //根据c2来构造一个c1，所有元素都会被拷贝map&lt; Elem &gt; c(n)     //生成一个大小为n的mapmap&lt; Elem &gt; c(n,elem)    //生成一个大小为n，每个元素都是elem的mapmap&lt; Elem &gt; c(bengin,end)    //生成一个map，区间begin和end之间的元素做为元素初值c.~map&lt; Elem &gt;()     //执行析构函数，销毁所有元素// multimap也是如此</code></pre><h2 id="map和multimap的非变动性函数"><a href="#map和multimap的非变动性函数" class="headerlink" title="map和multimap的非变动性函数"></a>map和multimap的非变动性函数</h2><pre><code>c.size();     //返回当前容器的元素数量c.empty();    //判断当前容器是否还有元素，有元素就返回falsec.max_size(); //返回容器所能容量的最大元素数量</code></pre><h2 id="map和multimap的特殊搜寻函数"><a href="#map和multimap的特殊搜寻函数" class="headerlink" title="map和multimap的特殊搜寻函数"></a>map和multimap的特殊搜寻函数</h2><pre><code>count(elem)                //返回“元素值==elem”的元素个数find(elem)                //返回“元素值==elem”的第一个元素，如果找不到就返回end()lower_bound(elem)        //返回elem的第一个可安插位置upper_bound(elem)        //返回elem的最后一个可安插位置equal_range(elem)        //返回elem可安插的第一个位置和最后一个位置</code></pre><h2 id="map和multimap的插入元素函数和删除元素函数"><a href="#map和multimap的插入元素函数和删除元素函数" class="headerlink" title="map和multimap的插入元素函数和删除元素函数"></a>map和multimap的插入元素函数和删除元素函数</h2><pre><code>c.insert(elem)            //插入elem元素副本，并返回元素新位置c.insert(pos,elem)        //在pos位置插入elem元素副本，返回新位置c.insert(begin,end)        //将区间[begin,end]内的元素插入到cc.erase(elem)            //删除“与elem”相等的元素，并返回被移除元素的个数c.erase(pos)            //删除迭代器pos所指的元素c.erase(begin,end)        //删除区间[begin,end]内的所有元素c.clear()                //删除容器内所有的元素// map也可以像数组一样使用[]操作符来进行对元素的赋值map&lt;int,string&gt;coll;coll.insert(makr_pair(1,"小陈"));coll[1]="小佐";//注意，这种方法一定要按照map的key/value的类型来进行操作，否则会发生一些未知的错误</code></pre><p>map和multimap的插入函数和set的大体一致，但是map插入的是 <code>key / value</code> 的pair时就比较复杂，有2个不同的方法可以将<code>value</code>传入<code>map</code>：</p><pre><code>1、直接运用pair&lt;&gt; :map&lt;int,string&gt; coll;coll.insert( pair&lt;int,string&gt;(1,"小明") );coll.insert( pair&lt;int,string&gt;(2,"小夫") );2、使用辅助函数 makr_pair() :map&lt;int,string&gt; coll;coll.insert(makr_pair(3,"胖虎") );coll.insert(makr_pair(4,"静香") );</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML统一建模语言整理</title>
      <link href="/2020/02/26/uml-tong-yi-jian-mo-yu-yan-zheng-li/"/>
      <url>/2020/02/26/uml-tong-yi-jian-mo-yu-yan-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="一、UML统一建模语言组成"><a href="#一、UML统一建模语言组成" class="headerlink" title="一、UML统一建模语言组成"></a>一、UML统一建模语言组成</h1><h2 id="1-1、基本元素"><a href="#1-1、基本元素" class="headerlink" title="1.1、基本元素"></a>1.1、基本元素</h2><p>按照可视化的角度来看，可以分为：</p><ul><li><code>视图</code></li><li><code>图</code></li><li><code>模型元素</code></li></ul><p>按照功能的不同又可以划分为：</p><ul><li><code>静态视图</code></li><li><code>用例视图</code></li><li><code>交互视图</code></li><li><code>状态机视图</code></li><li><code>活动视图</code></li><li><code>物理视图</code></li><li><code>模型管理视图</code></li></ul><p>下面会这些基本元素进行介绍。</p><h2 id="1-2-视图"><a href="#1-2-视图" class="headerlink" title="1.2 视图"></a>1.2 视图</h2><p>  UML是用模型来描述<strong>系统的结构</strong>、<strong>静态特征</strong>以及<strong>行为和动态特征</strong>的，各个构件和概念之间并没有很明显的划分界限，统一使用视图来概括这些概念和构建；视图只是表达系统某一方面特征的UML建模构件的子集；<br>  视图根据功能又划分为：<code>静态视图</code>、<code>用例视图</code>、<code>交互视图</code>、<code>状态机视图</code>、<code>活动视图</code>、<code>物理视图</code>、<code>模型管理视图</code>。</p><ul><li><p>静态视图<br>   静态视图是UML的基础，静态视图描绘的是客观现实世界的基本认知元素，是我们建立的一个系统中所需概念的集合；构造了这些概念对象的基本结构，静态视图不仅包括所有的对象数据结构，也包括了对数据的操作，即对象和方法；是建立其他动态视图的基础</p></li><li><p>用例视图<br>  用例视图描述了系统的参与者于系统进行交互的功能，是参与者所能观察和使用到的系统功能的模型图。    </p><ul><li>用例视图捕获了系统、子系统和用户执行的动作行为；</li><li>用户视图将系统描述为系统参与者对系统功能的需求，这种需求称作为用例；</li><li>用户视图使用用例图来表示。</li></ul></li><li><p>交互视图<br>  交互视图描述了执行系统功能的各个角色之间相互传递消息的顺序关系，是描绘系统中各种角色或功能交互的模型；适合描述一组对象的整体行为。</p></li><li><p>状态机视图<br>  状态机视图通过对象的各个状态来建立模型，用于描述对象随着时间变化的动态行为；<br>  状态机视图也是通过不同对象间的相互作用来描述系统的行为，对交互视图来说，它是以独立对象为中心来描述，而交互视图是以一组对象来描述的</p></li></ul><h2 id="1-3-图"><a href="#1-3-图" class="headerlink" title="1.3 图"></a>1.3 图</h2><p>  UML为了使开发过程中的应用程序更加容易理解，将模型进行图形化表示，而且严格定义了各种模型元素的符号，还包括了这些模型和符号的抽象语法和语义。<br>  最常用的UML图包括 <code>用例图</code>、<code>类图</code>、<code>序列图</code>、<code>状态图</code>、<code>活动图</code>、<code>构件图</code>和<code>部署图</code></p><ul><li>用例图</li><li>类图</li><li>序列图     </li></ul><p>   这些图后面有详细的片段去介绍。</p><h2 id="1-4-模型元素"><a href="#1-4-模型元素" class="headerlink" title="1.4 模型元素"></a>1.4 模型元素</h2><p>  我们在图中所使用到的基本概念统称为“模型元素”；模型元素使用相关的语义和关于元素的正式定义，在图中都有相应的元素表示；<br>  模型元素分为2部分：  <code>事物</code> 、 <code>关系</code> 。<br>   <code>事物</code> 是UML模型中基本的面向对象的模块，在模型中属于静态部分，定义了四种面向对象的事物，分别是结构事物、行为事物、分组事物、注释事物。    </p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/20200227155048.png" width="90%/"><p>  <code>关系</code>  UML模型是由各种事物以及这些事物之间各种关系构成的。这些关系指支配、协调各种模型元素存在并相互使用的规则；<br>  UML中主要包含七种关系：  <code>依赖</code>  、  <code>关联</code>  、  <code>泛化</code>  、  <code>实现</code>  、  <code>聚集</code>  、  <code>组成</code>  、  <code>包含</code>  、  <code>扩展</code>  。</p><hr><h1 id="二、用例图"><a href="#二、用例图" class="headerlink" title="二、用例图"></a>二、用例图</h1><p>   由参与者（Actor）、用例（Use case）以及它们之间的关系构成的用于描述系统功能的动态视图叫做用例图。用例图是需求分析的产物，主要作用是描述参与者和用例之间的作用，帮助开发人员可视化地了解系统的功能。</p><h2 id="2-1-用例图的构成要素"><a href="#2-1-用例图的构成要素" class="headerlink" title="2.1 用例图的构成要素"></a>2.1 用例图的构成要素</h2><ul><li><p>参与者<br>          参与者是指存在于系统外部并直接与系统交互的人、系统、子系统或类实体的抽象；通过参与者，可以对软件系统与外界发生的交互进行分析描述，可以了解客户希望软件系统提供哪些功能，用一个小人来表示。    </p></li><li><p>用例<br>  用例是系统为响应参与者引发的一个事件而执行的一系列的处理/动作，而这些处理应该为参与者产生一种由价值的结果，是用一个椭圆图形表示。    </p></li><li><p>系统边界<br>  用例图种的系统边接是用来表示正在建模的系统边界；边界内表示系统内部，边界外表示系统外部；系统边界决定了参与者，只要搞清楚了系统边界，才能更好地确定系统的参与者和用例。系统边界用一个长方形矩形框表示，内部表示内部，外面表示系统外部。    </p></li><li><p>关联<br>  关联表示了用例和参与者可能会存在的关系。    </p></li></ul><h2 id="2-2-用例规约"><a href="#2-2-用例规约" class="headerlink" title="2.2 用例规约"></a>2.2 用例规约</h2><p>  用例图只是在总体上大致描述了系统所提供的各种服务，但对每一个具体的用例还需要详细地描述信息，以便让别人对整个系统由更加详细的了解，这些信息包含在用例规约之中。    </p><p>用例规约应该包含以下内容：    </p><ul><li><p>简要说明<br> 简要说明是指对用例作用和目的的简要描述；    </p></li><li><p>事件流<br> 事件流包含 <code>基本流</code> 和 <code>备选流</code> ；<br>   基本流：是指用例在运行正常时所要经过的场景和选项；<br>   备选流：指用例在运行过程中可能发生的异常状况和场景选项；<br> 基本流和备选流组合起来能够覆盖一个用例所有可能会发生的场景。    </p></li><li><p>用例场景<br> 用例在实际执行的时候会有很多不同的情况发生，用例场景包括成功场景和失败场景，在用例规约中，由基本流和备选流的组合来对场景进行描述。    </p></li><li><p>特殊需求<br> 特殊需求是指一个用例的非功能性需求和设计约束。    </p></li><li><p>前置条件<br> 前置条件是指执行用例时系统必须所在的状态；想要执行用例，必须有某些前提条件，前提条件就是前置条件。    </p></li><li><p>后置条件<br> 后置条件是指用例执行完毕后系统可能出与的一组状态；执行完用例后，开发者想让系统所处的一个状态。</p></li></ul><hr><h1 id="三、类图和对象图"><a href="#三、类图和对象图" class="headerlink" title="三、类图和对象图"></a>三、类图和对象图</h1><h2 id="3-1-类图的组成"><a href="#3-1-类图的组成" class="headerlink" title="3.1 类图的组成"></a>3.1 类图的组成</h2><p>      在UML中，类的表示符号是一个矩形三角形，该三角形中从上到下分为三部分，这三部分分别代表了整个类的 类名称、属性、操作。<br><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/1.jpg" alt=""></p><h3 id="3-1-1-类的名称"><a href="#3-1-1-类的名称" class="headerlink" title="3.1.1 类的名称"></a>3.1.1 类的名称</h3><ol><li>类的名称时整个类图必须拥有的元素，同其他类进行区分；</li><li>是一个字符串，并且是名词；</li><li>类名词需要遵守大驼峰命名法（ 首字母大写，后面每一个单词的首字母都要大写）；</li><li>分为简单名称和路径名称。    </li></ol><h3 id="3-1-2-类的属性"><a href="#3-1-2-类的属性" class="headerlink" title="3.1.2 类的属性"></a>3.1.2 类的属性</h3><ol><li>类的属性是类的一个特性，也是类的组成部分，描述了类在软件系统中代表的事物（ 即对象 ）所具备的特性，这些特性是所有对象共有的；</li><li>类的属性用编程语言来表示，通常就是变量；</li><li>类的属性是可有可无的，并不是必须拥有，可以具有零个或者多个属性；<br> UML中，类属性的语法为： （[ ] 表示可选）<br>  [可见性] 属性名称 [：属性类型]  [=初始值] [{属性字符串}]    </li></ol><p>可见性包括： <code>Public （公开的）、Private（私有的）、Protected（受保护的）</code></p><table><thead><tr><th>Public （公开的）</th><th>外部类和内部类都可以使用和查看这些属性</th></tr></thead><tbody><tr><td>Private（私有的）</td><td>只有类本身才可以查看，外部一律查看不了，这个类派生（继承）的类也查看不了</td></tr><tr><td>Protected（受保护的）</td><td>这个类派生的子类可以访问这些被保护的属性</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-1-3-类的操作"><a href="#3-1-3-类的操作" class="headerlink" title="3.1.3 类的操作"></a>3.1.3 类的操作</h3><p>  类的操作指的是类所能执行的操作，是类的一个重要组成部分，描述了在软件系统中所代表的对象具备的动态部分的公共特征抽象；类的操作被放在类图的最底层，操作被称为方法或者函数。    </p><p>• UML中，类属性的语法为： （[ ] 表示可选）                 </p><p> [可见性] 属性名称 [：属性类型]  [=初始值] [{属性字符串}]</p><p>可见性包括： Public （公开的）、Private（私有的）、Protected（受保护的）</p><table><thead><tr><th>可见性</th><th align="center">分为 Public（公开）、Private（私有的）、Protected（受保护的），必选项</th></tr></thead><tbody><tr><td>操作名称</td><td align="center">必选项，用于区分别的方法操作</td></tr><tr><td>参数表</td><td align="center">有数据类型、标识符组成的序列，是由操作或者方法被调用是接收传递过来的参数值的变量，采用 “ 名称：类型”的方式定义，不是必须的</td></tr><tr><td>返回类型</td><td align="center">返回类型指定了由操作返回的数据类型，返回值只能返回一个，如果没有返回值，该处使用 void 关键字代替</td></tr><tr><td></td><td align="center"></td></tr></tbody></table><h3 id="3-1-4-类的关系"><a href="#3-1-4-类的关系" class="headerlink" title="3.1.4 类的关系"></a>3.1.4 类的关系</h3><p>  类于类之间的关系有4种：<code>依赖关系</code>、<code>泛化关系</code>、<code>关联关系</code>、<code>实现关系</code></p><hr><h1 id="四、序列图"><a href="#四、序列图" class="headerlink" title="四、序列图"></a>四、序列图</h1><p>  序列图用于对系统中一组对象群体的行为建模，主要用来表达对象之间的动作协作关系，通常用来描述用例的行为实现；序列图将交互关系表示为一个二维图，其中，纵向是时间轴，时间轴沿竖线向下延申。横向代表了在协作中各独立对象的角色。<br>  序列图是对对象之间传送消息的时间顺序的可视化表示。序列图的主要用途是把用例表达的需求，转化为进一步、更加正式层次的精细表达。</p><h2 id="4-1-序列图的组成"><a href="#4-1-序列图的组成" class="headerlink" title="4.1 序列图的组成"></a>4.1 序列图的组成</h2><p>  序列图由<code>对象</code>、<code>生命线</code>、<code>激活框</code>、<code>消息</code>组成</p><ul><li>对象    <ul><li>对象是类的实例，序列图中的对象可以是系统参与者，也可以是任何有效的系统对象;</li><li>使用矩形框来表示，显示的对象和类类名下面带有下划线，对象和类用冒号隔开;</li><li>对象的下面有一条生命线的垂直虚线。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/%E5%AF%B9%E8%B1%A1.png" alt="对象图"></p><ul><li><p>生命线</p><p>  生命线（Lifeline）是一条垂直的虚线，表示序列图中的对象在一段时间内的存在;每个对象的底部中心的位置都带有生命线;生命线是一个时间线，从序列图的顶部一直延伸到底部，所用的时间取决于交互持续的时间</p><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/shengmingxian.png" alt="生命线"></p></li><li><p>激活框</p><p>  序列图可以描述对象的激活（Activation），表示一个对象完成操作的过程;激活表示该对象被占用正在执行某个操作;激活在序列图中用一个细长的矩形框表示，矩形框称为激活条或控制期。<br>矩形框的顶端与激活时间对齐，而底端与完成时间对齐。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/diaoyong.png" alt="激活框"></p><ul><li>消息</li></ul><p>   消息是从一个对象（发送者）向另一个或几个对象（接收者）发送信号，或由一个对象调用另一个对象的操作;</p><p>  面向对象方法中，消息是对象间交互信息的主要方式表现为：    </p><blockquote><p>对象A向对象B发送消息，即为对象A调用对象B的一个成员函数</p></blockquote><p>  消息有三部分组成：<code>发送者</code>、<code>接收者</code>和<code>活动</code>。<br>  消息的表示形式为从发送者对象的生命线指向接收者对象生命线的箭头，箭头的类型表示了消息的类型。</p><p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/digui.png" alt="消息"></p><p>序列图所有元素的例图：<br><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/xulietu-all.png" alt="序列图所有元素"></p><hr><h1 id="五、活动图"><a href="#五、活动图" class="headerlink" title="五、活动图"></a>五、活动图</h1><p>  活动图是用于描述系统行为的模型视图，用来描述动作和动作导致对象状态改变的结果，而不用考虑引发状态改变的事件；考虑引发状态改变事件的图就是状态图。</p><p>  活动图表示一个程序或工作流，常用于计算流程和工作流程的建模；着重描述用例或者对象的活动，以及操作实现中所完成的工作。    </p><ol><li>描述一个操作执行过程中所完成的工作；</li><li>对用例图的工作流进行建模，显示用例内部和用例之间的路径；</li><li>显示如何执行一组相关的动作；</li><li>活动图对理解业务处理过程十分有用；活动图可以画出工作流用以描述业务，可以通过活动图来明确业务处理操作时如何进行的，以及可能产生的变化。</li></ol><h2 id="5-1-活动图的组成元素"><a href="#5-1-活动图的组成元素" class="headerlink" title="5.1 活动图的组成元素"></a>5.1 活动图的组成元素</h2><p>  活动图由<code>初态</code>,<code>终态</code>,<code>动作状态</code>,<code>活动状态</code>,<code>分叉与结合</code>,<code>分支和合并</code>，<code>泳道</code>组成。</p><ol><li><p>初态<br>活动图的起点，使用一个实心圆表示；有且只有一个。</p></li><li><p>终态<br>活动图的重点，使用一个黑心圆表示；可以有多个。</p></li><li><p>动作状态    </p><ul><li>没有入口、出口动作，没有内部转移；    </li><li>瞬时性；是瞬间完成的；    </li><li>不可中断；</li><li>具有原子性，意为不可再分解有自状态了；  </li></ul></li><li><p>活动状态    </p><ul><li>有入口、出口动作，有内部转移    </li><li>活动状态至少有一个输出完成转换    </li><li>活动状态可以分解，可以用另外一个活动图来描述自己的内部活动；    </li><li>活动状态和动作状态表示图标都一样，活动状态可以表出出口和入口动作    </li></ul></li><li><p>分支与合并    </p><ul><li>分支：将转换路径分为多个部分，每个部分都由单独的监护条件和不同的结果。当动作流到分支处会根据监护条件布尔表达式的真假来决定动作的流向，且每个动作流都是互斥的;    </li><li>合并：指的时两个或者多个控制路径再次汇合；    </li></ul></li></ol><blockquote><p>注意合并和结合的区别：合并是汇合了由分支分出了多个互斥的控制流，而且都会只走一条控制流；<br>而结合是汇合了两条或者更多条以上的并行控制流，在执行过程中，每一条路径都要走过，且每条控制流都走完后才能由结合继续往下转换。    </p></blockquote><ol start="6"><li>分叉和结合    <ul><li>分叉：表示将一个控制流分成两个或多个并发运行的分支；</li><li>结合：表示并行分支再次得到同步和结束。    </li></ul></li></ol><blockquote><p>注意:由分叉分出去的控制流，先完成的再结合处等待，只有当所有的控制流都到达结合点后，控制才会继续往下执行</p></blockquote><ol start="7"><li>泳道<br> 将参与者与系统或者参与系统中的类区分开来，可以在泳道里交叉线，但是不宜过多。</li></ol><hr><h1 id="六、状态图"><a href="#六、状态图" class="headerlink" title="六、状态图"></a>六、状态图</h1><p>    状态图用于描述一个对象在其生命周期期间可能会发生的行为和事件，清晰地描述了状态之间的转换顺序，通过转换的转换顺序也就可以清晰第看出事件的执行顺序。如果没有状态图我们就不可避免地要使用大量的文字来描述外部事件的合法顺序。</p><p>  清晰的事件顺序有利于程序员在开发程序时避免出现事件顺序错误的情况,状态图清晰地描述了状态转换时所必须的触发事件、监护条件和动作等影响转换的因素。</p><h2 id="6-1-状态图的组成"><a href="#6-1-状态图的组成" class="headerlink" title="6.1 状态图的组成"></a>6.1 状态图的组成</h2><p>  状态图由<code>状态</code>、<code>转换</code>、<code>事件</code>3个元素组成。</p><ul><li>状态<br>状态又分为<code>状态名</code>、<code>内部活动</code>、<code>内部转换</code>、<code>入口动作</code>、<code>出口动作</code>    <ol><li>内部活动：当进入状态时，就开始内部活动，当活动结束时，状态也就结束了</li><li>内部转换：状态可以包含一系列的内部转换，内部转换和内部活动不同，完成内部转换并不影响和改变状态的本身；内部转换只有源状态，没有目标状态，不会激发入口和出口动作。</li><li>入口动作：当进入状态时，入口动作被执行，在执行内部活动前执行入口动作；入口动作通常用于对状态进行内部初始化，因为最先执行的是入口动作。</li><li>出口动作：退出状态时会执行出口动作。</li></ol></li></ul><blockquote><p>内部活动和内部转换都是使用表达式来表达。</p></blockquote><ul><li>转换<br>转换表示2个状态之间的一种关系，即在一个在某初始状态的对象通过执行指定的动作并符合一定的条件下进入第二种状态；<br>转换又被分为：外部转换、内部转换、触发器事件、监护条件、动作；    <ul><li>外部转换：是一种改变状态的转换，用从源状态到目标状态的带箭头的线段表示；</li><li>监护条件：护条件是一个布尔表达式，是触发转换必须满足的条件；当监护条件的值为真时，转发可以激活。<blockquote><p>监护条件的值为假时，转换不能激活</p></blockquote></li></ul></li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客上线</title>
      <link href="/2020/02/25/bo-ke-shang-xian/"/>
      <url>/2020/02/25/bo-ke-shang-xian/</url>
      
        <content type="html"><![CDATA[<p>  很早之前就有搭建博客的想法，博客可以帮助自己构建知识体系，因为各种原因都没有成功，因为这次疫情的原因在家鼓捣电脑这个想法才得以实现，实在惭愧。在家的这段时间也开始真正思考自己以后的职业规划，因为实习过一段时间知道目前社会的工作常态都是一些什么样子的，要让自己在职场上更有竞争力那就得不停的学习。</p><blockquote><p>书山有路勤为径，学海无涯苦作舟。</p></blockquote><p>  在翻看一些职场人士的经验贴和视频，也有了一些系统学习的框架和思路，定制了一些学习计划目前也完成一段时间了，好脑子不如烂笔头，后续会陆续将一些学习笔记上传到博客，以便于跟踪定位自己的学习情况。当然也不排除发布其他的内容，像资源分享、心情笔记这一些内容，博客内容如若有错误的话请指出，我会及时修改的！谢谢支持！</p><img src="https://cdn.jsdelivr.net/gh/chenjianhao66/Myblog_picture-server/images/书籍.jpg" width="80%/"><p>贴一些在家期间自己所看的书籍</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2020/02/25/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2020/02/25/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
